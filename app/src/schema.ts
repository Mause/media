/**
 * This file was auto-generated by swagger-to-ts.
 * Do not make direct changes to the file.
 */

export interface components {
  schemas: {
    /**
     * Enum used to store the component types.
     */
    ComponentType: 'datastore' | 'internal' | 'http' | 'generic';
    DownloadAllResponse: {
      packs: components['schemas']['ITorrent'][];
      complete: [string, components['schemas']['ITorrent'][]][];
      incomplete: [string, components['schemas']['ITorrent'][]][];
    };
    DownloadPost: {
      tmdb_id: number;
      magnet: string;
      season?: number | null;
      episode?: number | null;
    };
    DownloadSchema: {
      id: number;
      tmdb_id: number;
      transmission_id: string;
      imdb_id: string;
      type: string;
      title: string;
      timestamp: string;
      added_by: components['schemas']['UserSchema'];
    };
    Episode: {
      name: string;
      id: number;
      episode_number: number;
      air_date?: string | null;
    };
    EpisodeDetailsSchema: {
      id: number;
      download: components['schemas']['DownloadSchema'];
      show_title: string;
      season: number;
      episode: number | null;
    };
    EpisodeInfo: {
      seasonnum: number;
      epnum?: number | null;
    };
    HTTPValidationError: {
      detail?: components['schemas']['ValidationError'][];
    };
    HealthcheckResponse: {
      component_name: string;
      component_type: components['schemas']['ComponentType'];
      status: components['schemas']['HealthcheckStatus'];
      time: string;
      output: unknown;
    };
    /**
     * Enum used to store the possible service and component health status.
     */
    HealthcheckStatus: 'pass' | 'warn' | 'fail';
    ITorrent: {
      source: components['schemas']['ProviderSource'];
      title: string;
      seeders: number;
      download: string;
      category: string;
      episode_info?: components['schemas']['EpisodeInfo'] | null;
    };
    IndexResponse: {
      series: components['schemas']['SeriesDetails'][];
      movies: components['schemas']['MovieDetailsSchema'][];
    };
    InnerTorrent: {
      eta: number;
      hashString: string;
      id: number;
      percentDone: number;
      files: components['schemas']['InnerTorrentFile'][];
    };
    InnerTorrentFile: {
      bytesCompleted: number;
      length: number;
      name: string;
    };
    /**
     * An enumeration.
     */
    MediaType: 'series' | 'movie';
    MonitorGet: {
      tmdb_id: number;
      type: components['schemas']['MonitorMediaType'];
      id: number;
      title: string;
      added_by: components['schemas']['UserSchema'];
      status: boolean;
    };
    /**
     * An enumeration.
     */
    MonitorMediaType: 'MOVIE' | 'TV';
    MonitorPost: {
      tmdb_id: number;
      type: components['schemas']['MonitorMediaType'];
    };
    MovieDetailsSchema: {
      id: number;
      download: components['schemas']['DownloadSchema'];
    };
    MovieResponse: {
      title: string;
      imdb_id: string;
    };
    /**
     * An enumeration.
     */
    ProviderSource:
      | 'kickass'
      | 'horriblesubs'
      | 'rarbg'
      | 'torrentscsv'
      | 'nyaasi'
      | 'piratebay';
    SearchResponse: {
      title: string;
      type: components['schemas']['MediaType'];
      year: number | null;
      imdbID: number;
    };
    SeasonMeta: {
      episode_count: number;
      season_number: number;
    };
    SeriesDetails: {
      title: string;
      imdb_id: string;
      tmdb_id: number;
      seasons: {
        [key: string]: components['schemas']['EpisodeDetailsSchema'][];
      };
    };
    Stats: {
      episode: number;
      movie: number;
    };
    StatsResponse: {
      user: string;
      values: components['schemas']['Stats'];
    };
    TvResponse: {
      number_of_seasons: number;
      seasons: components['schemas']['SeasonMeta'][];
      imdb_id: string | null;
      title: string;
    };
    TvSeasonResponse: {
      episodes: components['schemas']['Episode'][];
    };
    UserSchema: {
      username: string;
      first_name: string;
    };
    ValidationError: {
      loc: (string | number)[];
      msg: string;
      type: string;
    };
  };
}
